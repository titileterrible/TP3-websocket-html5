<!DOCTYPE HTML>
<html lang="fr">
<head>
<meta charset="UTF-8">
</head>
    
    <script src="socket.io/socket.io.js"></script>
 
    <link href="jquery-ui/css/ui-lightness/jquery-ui-1.9.2.custom.css" rel="stylesheet">
	  <script src="jquery-ui/js/jquery-1.8.3.js"></script>
	  <script src="jquery-ui/js/jquery-ui-1.9.2.custom.js"></script>
    
      
    <link type="text/css" href="jquery-ui/css/jquery.ui.chatbox.css" rel="stylesheet" />
    <script type="text/javascript" src="jquery-ui/js/jquery.ui.chatbox.js"></script>
    <script src="common.js"></script>
    
    <script src="utils.js"></script>
    
    <style>
        body {
            margin: 10px;
            padding: 0px;
            width: 1100px;
        }
        #containerEcran{
          /*border:1px solid #000000; */
          box-shadow: -1px 2px 5px 1px rgba(0, 0, 0, 0.7); 
          margin:5px;
          padding:5px;
          /*max-width:1050; 
          min-width:1050; /**/
          width:810px;
          }
        #containerAiredejeu {
            float:left;
            }  
          #myCanvas,#messageCanvas {
              /*border: 1px solid #9C9898;  */
              box-shadow: -1px 2px 5px 1px rgba(0, 0, 0, 0.7);
              margin:5px; 
              }
        #containerConnectes {
          float:left;
          width:165px;
          /*border:1px solid black; */
          box-shadow: -1px 2px 5px 1px rgba(0, 0, 0, 0.7); 
          margin: 5px;
          /*height:300px;*/
          padding:10px;
          overflow:scroll-y;
          }
          #containerPilotes {}
          #containerUsers {}
        #containerTchat {
          float:left;
          width:300px;
          height:250px;
          overflow:scroll-y;
          padding:10px;
          }
          #containerConversation {
            width;340px;
            border:1px solid #cccccc;
            margin-top:5px;
            padding:2px;
            overflow:hidden;
            
            }
          #containerSend {}
    
    
    
    
    </style>
    
   
   <script>
    
    // TODOLIST:
    // DO Repositionner joueurs si sortie de piste... 
    // DO Bug regression > Fillcolor collisions du joueur 1...
    // DO Sortie du joueur ayant terminé le niveau...
    // DO Tests de passage de niveau
    // DO Messages de cible atteinte
    // DO Messages de sortie de piste
    // DO Messages de fin de niveau
    // DO Bug regression ( suite message ) > Fillcolor collisions.
    // DO Zone de départ protégée des collisions
    // DO Matérialiser la zone de départ protégée
    // DO Zone d'affichage dédiée...
    // DO Axe rebonds sur collision aléatoire ( supprimé because synchro websocket)
    // DO Rebonds multidirectionnels
    // DO Perte de contrôle temporisée en cas de collision
    // DO Rebonds dynamiques des cibles en cas de collision
    // DO Factoriser la création de joueurs en une seule fonction
    // -- Limiter le nombre de joueurs à 10 par exemple...
    // DO Automatiser le placement des joueurs en fonction de leur nombre
    // DO Passage de niveau : augmentation du nombre d'obstacle
    // DO BUG recession rebond collision joueur 1.
    // DO compte a rebours sur passage de niveau.
    // DO incrémentation du score de chaque joueur
    // DO BUG collision cible fantome avec joueur gagnant? 
    // - Lancement du jeu avec un bouton play...
    // DO Mise en en place d'un compte a rebour...
    // DO Mise en place d'un chronomètre...
    // DO interruption du chrono entre chaque niveau
    // - mémorisation temps intermédiaires 
    // - chronos individuels par joueurs
    // DO Affichage du framerate de la machine cliente.
    // DO Affichage des scores finaux
    // - Couleur des messages
    // DO Gestion de la Pole position selon classement
    // -----------------------------------------------------
    // - En option ( si le temps le permet )
    
    // DO Fragmentation obstacles sur collisions joueurs
    // --- Effets sonores
    // --- Musique
    // --- Vidéo
    // --- Sprites
    
    // Partie Websocket...
    // DO Creation fihier bat lancement node js
    // DO reprise structure code > meilleur lisibilité
    // DO adaptation numérotation liste joueurs
    // DO synchro listeJoueurs locale/serveur
    // DO gestion limite max joueurs
    // DO recalage pole position sur liste joueurs
    // DO lancement auto si nbre joueurs max inscrits
    // DO Verouillage session de jeu sur lancement auto
    // >> DO Desactivation bouton start joueurs 
    // DO Lancement manuel bouton 
    // >> DO verouillage session jeu sur lancement manuel
    // >> DO Desactivation bouton start joueurs
    // DO Reinitialisation flags serveurs si plus de joueurs
    // DO récupération d'office des flags serveur a la connection
    // DO Désactivation du bouton Start pour les simples connectés
    // DO BUG Décalage Synchro startlevel sur démarage manuel...
     
    // DO Individualisation tests touches pilotage client
    // DO envoi + reception mouvements joueurs
    // Nettoyer et refactoriser le code
    // synchroniser le loop
    // DO BUG "partis" >>>> Vidage liste qd joueurs all deconnected
    // mettre en place un multiroom
    // Encours Syncrho framerate selon navigateur
    // DO Affichage de la liste des coureurs pour les simples connectés
    // ( ANNULE >>> plus le temps... ) Visualisation course en mode 'spectateur'...
    // DO BUG sur IE...
    // DO Affichage chat ds liste déroulante >> jqueryBox
    // DO Reprise css générales...
     
    
    // ----------------------------------------------------------
    // Finalisation :
    // OK Reprendre le code client et externaliser le maximum de fonctions
    // OK Rendre les fonctions accessibles coté client comme coté serveur.
    // OK Tester. Si tt est OK :
    // -- ensuite : 
    // OK Créer les obstacles coté serveur
    // OK Synchroniser les positions obstacles...
    // OK Synchroniser la création de débris a la volée...
    // OK Synchroniser la positions des débris  
    // ( annulé, plus le temps.... ) Enfin, faire un systeme de prédiction et d'interpolation pour
    // ---- Joueurs
    // ---- Obstacles
    // ---- Debris
    // -- Ajouter les messages de collision ds le tchat
    // -- Ajouter les messages les sorties de pistes
    // -- ( annulé, plus le temps.... ) Mettre le tout en multiroom
    // -- ( annulé, plus le temps.... ) Connectés entrant >>> Nvelle Room
    // -- Si ok > Supprimer la liste des connectés et des Users...
    // -- Trouver un moyen de simuler le lag...
    
      
     // ----------- variables de dev
     var cptStartLevel = 0;
     
     
     // ------------------- Flags d'état
     var gameSession = false; // Bloque le startlevel
     var lockGameSession = false; // Bloque l'inscription de nouveaux joueurs
     var maxPlayersSession = 6; // Nombre de joueurs maximum
     var activeSendPos = false; // Flag de synchro...
    
    
    var targetX = 500, targetY = 200, targetRadius = 30;
    var freesePlayerTime = 2000; 

    // Tableau des joueurs...
    var listeJoueurs = new Array();
    var faitchier = {};
    var nbJoueurs =  listeJoueurs.length;
    
    // Variable de message
    var message = "";
    
    // on initialise le 1er niveau
    //var level = new level();
    var level = new common.level();
    level.number = 1;
    level.endLevel = false;
    level.chrono = 0;
    level.type = "Niveau ";
    
    // Activation du niveau
    var activeLevel = false;
      
    // Pour le compte a rebour
    var secondeDecompte = 3;
    // Le clearInterval etant capricieux
    // On le double par un simple flag d'état...
    var endDecompte = false; 
    
    // Tableu d'obstacles vide
    var obstacles = new Array();
    
    // Tableau de débris vide 
    var debris = new Array();
    
    // Le nombre de niveaux correspond au nombre d'obstacles...
    // var maxLevels = obstacles.length;
    var maxLevels = 0;
    /**/
    
    // generic way to set animation up
    window.requestAnimFrame = (function(callback){
        return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
    })();
    
   

// --------------------------------- Séquence de chargement        
window.onload = function () {
                  
            // -----------------
            enableStartButton();
            var canvas = document.getElementById('myCanvas');
            var context = canvas.getContext('2d');
            var started = false, previousMousePos;
            var mousePos;
            var vitesseX=0; vitesseY = 0;
          
            // Pour calculer le framerate
            var show_fps = true;
            var lastrun = 0;
            
            // Flag d'etat de fin de jeu
            var endGame = false;
            
            // Initialisation du chrono
            var startTime = 0; 
           
           // A la reception des autres joueurs
           // Update des mouvements des joueurs
           function updateMovesInListPlayers(listeJoueurs,moveObject){
                 for ( player in listeJoueurs ){
                      if ( listeJoueurs[player].idUnique == moveObject.idUnique ) {
                            listeJoueurs[player].playerX = moveObject.playerX;
                            listeJoueurs[player].playerY = moveObject.playerY;
                            listeJoueurs[player].vitesseX = moveObject.vitesseX;
                            listeJoueurs[player].vitesseY = moveObject.vitesseY;
                      }
                 
                 }
           }
                   
           
           // Envoi des coordonnées joueur au serveur
           // sous forme d'un objet playerMove
           function sendToServerPlayerMoves(clientPlayer){     
                var moveObject = new common.playerMove(clientPlayer.idUnique
                                ,clientPlayer.playerX
                                ,clientPlayer.playerY
                                ,clientPlayer.vitesseX
                                ,clientPlayer.vitesseY
                                );                                
                 moveObject.idUnique = clientPlayer.idUnique;
                 moveObject.playerX = clientPlayer.playerX;
                 moveObject.playerY = clientPlayer.playerY;
                 moveObject.vitesseX = clientPlayer.vitesseX;
                 moveObject.vitesseY = clientPlayer.vitesseY ;
                
                 socket.emit('senpPlayerMovesObject', moveObject);
           }
           /**/
           
    
           
           // Pour l'appui sur une touche,
           // on boucle sur tous les joueurs de la liste
           // et on teste le joueur local et les touches qui lui sont affectées
           function checkArrowKeysUp2(e){
              var arrs= [], key= window.event? event.keyCode: e.keyCode;
              for (joueur in listeJoueurs){
                 common.checkCollisionsWithObstacles2(context,listeJoueurs[joueur]);
                 if  (listeJoueurs[joueur].idUnique == clientPlayer.idUnique ) {
                    if (common.doChrono(listeJoueurs[joueur].lastTimeCollision) > freesePlayerTime ) {
                         if(key == listeJoueurs[joueur].KeyLeft) {listeJoueurs[joueur].vitesseX= 0;} 
                         if(key == listeJoueurs[joueur].KeyRight) {listeJoueurs[joueur].vitesseX=0;}
                         if(key == listeJoueurs[joueur].KeyUp) {listeJoueurs[joueur].vitesseY=0;}
                         if(key == listeJoueurs[joueur].KeyDown) {listeJoueurs[joueur].vitesseY=0;}
                     }
                   
                  }
              }  
           }
          
           // idem pour le relachement de touches
           function checkArrowKeysDown2(e){
              var arrs= [], key= window.event? event.keyCode: e.keyCode;
              for (joueur in listeJoueurs){
                  common.checkCollisionsWithObstacles2(context,listeJoueurs[joueur]);
                  if  (listeJoueurs[joueur].idUnique == clientPlayer.idUnique ) {
                     if (common.doChrono(listeJoueurs[joueur].lastTimeCollision) > freesePlayerTime ) {
                       if(key == listeJoueurs[joueur].KeyLeft) {listeJoueurs[joueur].vitesseX= -4;} 
                       if(key == listeJoueurs[joueur].KeyRight) {listeJoueurs[joueur].vitesseX=4;}
                       if(key == listeJoueurs[joueur].KeyUp) {listeJoueurs[joueur].vitesseY=-4;}
                       if(key == listeJoueurs[joueur].KeyDown) {listeJoueurs[joueur].vitesseY=4;}
                     }
                  }
              } 
          }
          /**/
        
          document.onkeydown=checkArrowKeysDown2;
          document.onkeyup=checkArrowKeysUp2;
       
    

      // Organisation de la pole position
      function startPolePosition (context,canvas,listeJoueurs,level) {
            
            // ObjectDump(listeJoueurs, 'listeJoueurs');
            
            var debug = 'StartPolePosition()'; 
            
            debug += "\n level-number:"+level.number;
            debug += "\n nbJoueurs:"+nbJoueurs;
            
            var milieu = canvas.height/2;
            var lignePlayer = nbJoueurs*60;
            var retrait = lignePlayer/2;
            var posY = milieu-retrait-45;
            
            // On trie les joueurs par scores pour la pole position
            listeJoueurs.sort(function(a,b) {
              return b.score - a.score;
            });
            /**/
            var podium = 1;
            var polePosX = 20;
            for (joueur in listeJoueurs) {
              posY += 60;
              // Si on a passé le premier niveau
              // on affecte la pole position au 3 premiers
              if ( level.number > 1) {
                if ( podium == 1) polePosX = 40;
                else if ( podium == 2) polePosX = 30 ;
                else if ( podium == 3) polePosX = 15 ;
                else  polePosX = 5 ;
              }
              listeJoueurs[joueur].playerX = polePosX ;
              listeJoueurs[joueur].startX = polePosX ;
              listeJoueurs[joueur].playerY = posY;
              listeJoueurs[joueur].startY = posY;
              podium ++;
            }
      }       
          
          
      // -------------------------------- intégration WebSockets
     
     	var socket = io.connect('http://localhost:8080');
      
      // Création objet joueur avec paramètres par défaut
      var clientPlayer = new common.joueur('incognito','green',0,37,38,39,40);
      // On lui attribue un UUID
      clientPlayer.idUnique = common.createUUID();
      
      // Initialisation du flag spectateur
      // var spectateur = false;

       // Listener : reception d'un mouvement joueur 
      socket.on('updateMoves', function(moveObject) { 
          updateMovesInListPlayers(listeJoueurs,moveObject);
      });

      // Désactivation du bouton start
      function disableStartButton(){
        $("#startsend").prop('value', '...Course lancée...');
        $("#startsend").prop('disabled',true);
      }       
     
      function enableStartButton(){
        $("#startsend").prop('disabled',false);
       }
      
      // Listener >>> Qd le serveur répond a la requête  'getLockGame'
      socket.on('receiveLockServerGame', function (lockServerGameSession) {
          lockGameSession = lockServerGameSession;
          // Si le jeu est déjàs lancé ( inscriptions closes )
          if  ( lockGameSession == true) {
                disableStartButton();
                // puis demande de la liste des joueurs pour affichage...
                socket.emit('getSpectateursListPlayers');
                }
      });
          
      
      
      
      // on connection to server, ask for user's name with an anonymous callback
      socket.on('connect', function(){       
        // On Demande les éléments au serveur
        socket.emit('getLockGame'); //  receiveLockServerGame
        socket.emit('getListObstacles'); //  receivedObstacles
        
        messagePrompt = "Nom ?";
        clientPlayer.name = prompt(messagePrompt);
        if (clientPlayer.name == null || clientPlayer.name == '' || clientPlayer.name == 'undefined' ) return;
        // S'il reste de la place, dans la liste des joueurs...
        socket.emit('addPlayer', clientPlayer,maxPlayersSession,lockGameSession);
        // D'office sur le tchatt
        socket.emit('adduser',clientPlayer.name);
        
        
      });
      
      
      // Listener >>> Qd le serveur répond a la requête  'getNbPlayers'
      socket.on('receiveNbPlayers', function (nbPlayers) {
          nbPlayersSession = nbPlayers;
      });
      
      
       // Listener >>> Qd le serveur répond a la requête  'getListPlayers'
       socket.on('receiveListPlayers', function(listePlayers){
          // Mise a jour simple de l'Affichage liste pilotes
          $('#listePlayers').empty();     
          $.each(listePlayers, function(key, value) {
      		  $('#listePlayers').append('<div>' + key + '</div>');
      		});
       
       });

      
       // Ajout d'un chatbox jquery...
       var box = $("#chat_div").chatbox({id:"chat_div", 
          user:{key : "value"},
          title : "Messages",
          messageSent : function(id, user, msg) {
              socket.emit('sendchat', msg);
        }});

      // listener, whenever the server emits 'updatechat', this updates the chat body 
    	socket.on('updatechat', function (username, data) {
    		//$('#conversation').append('<b>'+username + ':</b> ' + data + '<br>');
        // On passe par le chatbox jquery, c'est plus cool
    	  $("#chat_div").chatbox("option", "boxManager").addMsg(username, data);
      });


      // listener, whenever the server emits 'updateusers', this updates the username list
    	socket.on('updateusers', function(data) {
        $('#users').empty();
        $.each(data, function(key, value) {
    			$('#users').append('<div>' + key + '</div>');        
        });
      });
      
      // Listener : Mise a jour du flag de vérouillage et lancement
      socket.on('updateLockServerGame', function(lockServerGameSession) { 
        gameSession = true;
        lockGameSession = true;
        disableStartButton();
        startLevel();
      });
      

      // Mise a jour de la liste locale des joueurs...
      // mode sepctateur...
    	socket.on('updatePlayersForSpectateurs', function(data) { 
        // Mise a jour de l'Affichage liste pilotes
        $('#listePlayers').empty();     
        $.each(data, function(key, value) {
    			$('#listePlayers').append('<div>' + key + '</div>');
    		});
        
    	});
      
      // Mise a jour de la liste locale des obstacles
      socket.on('receivedObstacles', function(data) { 
        // ObjectDump(data, 'receivedObstacles')
        obstacles = new Array();    
        for (var i in data) { 
              obstacles.push(data[i]);  
        }
        maxLevels = obstacles.length;
    	});
      
      
      // Mise a jour de la liste locale des débris
      socket.on('receivedDebris', function(data) { 
        debris = new Array();    
        for (var i in data) { 
              debris.push(data[i]);  
        }
    	});
       
      // Nettoyage de la piste coté serveur
      var  clearDebris = function(){
         socket.emit('clearDebris');
      };
      
      // listener, whenever the server emits 'updateusers', this updates the username list
      // Mise a jour de la liste locale des joueurs...
    	socket.on('updatePlayers', function(data) { 
        // On vide la liste ( pour virer les joueurs déconnectés)
        listeJoueurs = new Array();
        var debugmessage = "";
        // Et on la recrée...        
        for (var i in data) {
             listeJoueurs.push(data[i]);
        }
        // On place les pilotes en pole Position
        startPolePosition (context,canvas,listeJoueurs,level);
        
        // Mise a jour de l'Affichage liste pilotes
        $('#listePlayers').empty();     
        $.each(data, function(key, value) {
    			$('#listePlayers').append('<div>' + key + '</div>');
          //$('#listePlayers').append('<div> N°' + value.number + " " +value.name + '</div>');
    		});
        
        // Lancement auto...
        // Uniquement si la session de jeux n'est pas encore vérouillée...
        if (lockGameSession == false) {
           // Si le nombre max d'inscrits est atteind...
           if (listeJoueurs.length == maxPlayersSession) {
                gameSession = true;
                lockGameSession = true;
                disableStartButton();
                // On lance le startlevel
                startLevel();
           }
        }

        
    	});

    	
      
      // boutons Jquery
    	$(function(){
      		
          
          // Bouton Start...
          $('#startsend').click( function() {
             if (lockGameSession == false) { 
                gameSession = true;
                lockGameSession = true;
                socket.emit('sendLockGame', lockGameSession);
                disableStartButton();
              }
          });
          
          
          
          // when the client clicks SEND
      		$('#datasend').click( function() {
      			var message = $('#data').val();
      			$('#data').val('');
      			// tell server to execute 'sendchat' and send along one parameter
      			socket.emit('sendchat', message);
      		});

        
        });
       
      
      // --------------------- end CHAT ------------------ 
       
           // Envoi de la position du joueur 
           // toutes les 15 millisecondes...
           function sendPos(){
                var debug = '';
                 if (activeSendPos == true ) {
                    for (joueur in listeJoueurs){
                              if  ( listeJoueurs[joueur].idUnique == clientPlayer.idUnique ){
                                   sendToServerPlayerMoves(listeJoueurs[joueur]);
                              };
                    }; 
                setTimeout(sendPos,15); // rappel après 15 millisecondes
                
                }
           };  
          
          
          // Idem pour les obstacles et les débris
          // Mais moins souvent...
          function sendObstacles(){
                var debug = '';
                // ObjectDump(obstacles, 'obstacles')
                 if (activeSendPos == true ) {
                      socket.emit('sendPlayerObstacles', obstacles);
                      socket.emit('sendPlayerDebris', debris);
                    };  
                //socket.emit('senpPlayerObstacles', obstacles);
                setTimeout(sendObstacles,5000); 
                
           };
 
          
          
          
          
          
          // Pole position
          startPolePosition (context,canvas,listeJoueurs,level);
          
         
          // Fonction de lancement de niveau
          function startLevel() {
           
           if ( gameSession == true ) {   

              // debug
              cptStartLevel +=1;
              nbJoueurs = listeJoueurs.length;
              startPolePosition (context,canvas,listeJoueurs,level);
              
              // on check si c'est le dernier niveau...
              if (level.number > maxLevels) endGame = true;
              if (endGame == true) {
                
                var endMessage = "GAME OVER";
                // Affichage du classement final
                common.showScores(canvas,context,listeJoueurs,startTime,level,endMessage);
              
              } else {
                // Affichage du classement intermédiaire
                if (startTime != 0 ) {
                  common.showScores(canvas,context,listeJoueurs,startTime,level);
                  }  
                // On vire les débris de la piste
                clearDebris();
                
                startTime = 0;
                activeLevel = true;
                secondeDecompte = 3;
                endDecompte = false;
                timer = setInterval(common.decompte,1000);
                lastRun = 0;
                // Démmarage de la fonction SenPos tte les 15 ms...
                activeSendPos = true;
                sendPos();
                sendObstacles(); 
                setTimeout(mainLoop, 4000);
              }
          
            }
          
          } // ----------- End StartLevel
          
          
          
          // Boucle d'animation  ------------------------------------------
          var thisloop = 0;
          function mainLoop() {

            // Lancement et affichage du Chrono
            if(startTime == 0) startTime = new Date();
            //showChrono(startTime);
            common.showChrono(startTime);
            
            // Pour calculer le framerate
            // Adapté de: http://jsfiddle.net/vZP3u/
            if(lastRun == 0) {lastRun = new Date().getTime();}
            //if (show_fps) lastRun = showFPS(lastRun);
            if (show_fps) lastRun = common.showFPS(lastRun);
                      
            // Effacement, dessin, collisions, etc.
            context.clearRect(0,0, canvas.width, canvas.height);
            
            // Zone protégée
            // drawStartLine(context,canvas);
            common.drawStartLine(context,canvas);
            
            // Contrôle de fin de niveau
            //checkLevel(level);
            common.checkLevel(level);
            
            // Message de dialogue
            //writeMessage(message, level);
            common.writeMessage(message, level);
            
            // Si le niveau est terminé,
            // On l'incrémente et on met l'état
            // du niveau actif a false.
            if (level.endLevel == true) {
                  common.passLevel(level);
                  activeLevel = false;
                }
            
            // Tant que le niveau est actif,
            // On execute la suite
             if (activeLevel == true){
             
                // Gestion des sorties de piste...
                for (joueur in listeJoueurs){
                  common.checkSortieDePiste(canvas,listeJoueurs[joueur]);
                } 

                // Dessin des obstacles
                common.drawObstacles(canvas,context,level);
                                
                
                // Dessin des débris
                common.drawDebris(canvas,context,debris)
                
                // Dessin des joueurs
                for (joueur in listeJoueurs){
                   common.drawOnePlayer2(canvas, context,listeJoueurs[joueur]);
                }
                
                // Déplacement des joueurs
                for (joueur in listeJoueurs){
                        listeJoueurs[joueur].playerX += listeJoueurs[joueur].vitesseX;
                        listeJoueurs[joueur].playerY += listeJoueurs[joueur].vitesseY; 
                }
                
                // Test Collisions obstacles
                for (joueur in listeJoueurs){
                   var touche = false;
                   touche = common.checkCollisionsWithObstacles2(context,listeJoueurs[joueur],debris);
                   if (touche) {break;};
                } 
                
                // Test de Collisions Débris
                for (joueur in listeJoueurs){
                   var touche = false;
                   touche = common.checkCollisionsWithDebris(context,listeJoueurs[joueur],debris);
                   if (touche) {break;};
                }
                                
                
                // Test Collision cible
                for (joueur in listeJoueurs){

                  // On ne teste pas les joueurs déjas arrivés...
                  if ( listeJoueurs[joueur].level == false ) {  
                     if(common.circRectsOverlap(listeJoueurs[joueur].playerX, listeJoueurs[joueur].playerY, 20, 20, targetX, targetY, targetRadius)) {                                         
                         common.drawTarget(canvas, context, targetX, targetY, targetRadius, 'yellow');
                         
                         // Pour affichage...
                         var oldScore = listeJoueurs[joueur].score;
                         
                         // On désactive ce joueur pour ne liveau courant
                         listeJoueurs[joueur].level = true;
                                                  
                         // On le décompte du total de joueurs actifs
                         nbJoueurs = nbJoueurs-1;
                         
                         // incrémentation du score
                         // Le premier marque (n -1) points, le dernier 0 points, n étant le nombre de joueurs...
                         // Ex: sur 3 joueurs, le 1er gagne 2, le second 1 et le troisième 0...
                         // Il suffit donc d'ajouter à son score le nombre de joueurs derrière lui... 
                         listeJoueurs[joueur].score +=  nbJoueurs;
                         
                         // Message 
                         message = "Joueur N°"+listeJoueurs[joueur].number;
                         message += " ("+listeJoueurs[joueur].name+")";
                         message += " > Score "+ oldScore +" + "+nbJoueurs+" = "+listeJoueurs[joueur].score;                         
                         
                         break;  
                      } else {                    
                         common.drawTarget(canvas, context, targetX, targetY, targetRadius, "#8ED6FF");
                      }
                   }   

                 }
                
            } // Fin de boucle sur niveau actif    

            // On reexecute la fonction mainloop après 60ms
            requestAnimFrame(function(){
                // Tant que le niveau est actif... on boucle...
                if (activeLevel == true){
                    mainLoop();
                // Sinon, on lance le niveau suivant..
                } else {
                  startLevel();
                }
            });
          } // -------------- fin  mainLoop()

          startLevel();
        };
    
    </script>


 <body style="width:">

 
 <div id="containerEcran">

    <div id="containerAiredejeu">
      
      <canvas id="messageCanvas" width="600" height="35">
      </canvas>
       <br/>
      <canvas id="myCanvas" width="600" height="400">
      </canvas>
      <div>
        <span id = "chrono"></span>
        -
        <span id = "fps"></span>
      </div>
    
    </div>

 
    <div id="containerConnectes">
    	
      <div id="containerPilotes">
        <b>Pilotes engagés</b>
      	<div id="listePlayers"></div>
        <input type="button" id="startsend" value="Lancer la course" />
      </div> 
      <hr>
      <div id="containerUsers">
        <b>Connectés</b>
      	<div id="users"></div>
      </div>
      <hr>
      
    
    </div>

     <div class="hidden" style="display:none;">
        <div id="chat_div"></div>
        <hr />
        <div id="log"></div>  
    </div>
      
    <div style="clear:both"></div>

</div>


</body>
</html>